# 分布式服务框架Dubbo

## Dubbo原理

[分布式服务框架](Dubbo.md)

## Dubbo支持哪些序列化协议

1. Dubbo支持哪些通信协议
    - dubbo://协议
        - 默认协议，单一长连接，进行的NIO异步通信，基于hessian作为序列化协议
        - 特性，传输数据量小(每次100k以下)；并发量高，适用多个消费者的情况
    - rmi://协议
        - 采用JDK标准的Java.rmi.*实现
        - 特性，多个短链接，适合消费者和提供者差不多的情况，**适用文件传输**
    - hessian://协议
        - http通信，采用servlet暴露服务，基于hessian序列化协议
        - 多个短链接，适用于提供者数量多的情况，**适用文件传输**
    - http://协议
        - 基于http表单的远程通用协议，走单表序列化
    - thrift://协议
        - 在原生协议的基础上添加了一些额外的头信息，如service name，magic number等
    - webservice://协议
        - 基于apache cxf的fronted-simple和transports-http实现，SOA文本序列化
    - memcached://协议
        - RPC协议
    - redis://协议
        - RPC协议
    - rest://协议
        - 实现REST调用支持
    - grpc://协议
        - 适用HTTP/2通信，想利用Stream、反压、Reactive变成能力的开发者适用
2. 支持的序列化协议

支持hessian，java二进制序列化，SOAP文本序列化，json多种序列化协议

## Dubbo的负载均衡策略和集群容错策略

4中负载均衡策略，6种集群容错策略

### Dubbo的负载均衡策略

1. **RandomLoadBalance，默认策略，随机调用；可以对provider设置不同的权重，按照权重来负载均衡。**

   算法思想：假设有一组服务器servers=[A,B,C],对应权重为weights=[5,3,2],总和为10.把权重平铺在一纬坐标值上，则[0,5]服务器A,[5,8]服务器B,[8,10]
   属于服务器C.随机数生成器生成一个范围在[0,10]之间的随机数，然后计算会落在哪个区间的服务器，坐标轴上区间范围大的，随机数生成的数字就有更大概率落到此区间

2. **RoundRobinLoadBalance，均匀分发**

   算法思想：均匀地将流量打到各个机器上，但是如果各个机器性能不同，容易导致性能差的机器负载过高。所以需要调整权重，让性能差的机器承载权重小一些，流量少一些
3. **LeastActiveLoadBalance，最小活跃数负载均衡，活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多请求，此时请求会优先分配给该服务提供者**

   算法思想：每个provider对应一个活跃数active。初识情况，provider的active均为0.每收到一个请求，对应的provider的active会加1，处理完请求后，active会减1.所以，如果provider性能好，处理请求的效率就越高，active下降的越快。也引入了权重值，所以此算法是基于加权最小活跃数算法实现
4. **ConsistenHashLoadBalance，一致性hash**

   算法思想：一致性Hash算法，相同参数请求一定分发到一个provider去。如果需要的不是随机负载均衡策略，要一类请求都到一个节点，那就走一致性Hash策略

### 集群容错策略

1. **Failover Cluster模式**，默认这个，失败自动切换，自动重试其它机器，常见于读操作
2. **Failfast Cluster模式**，一次调用失败就立即失败，常见幂等性的写操作，如新增一条记录
3. **Failsafe Cluster模式**，出现异常时忽略，用于不重要的接口调用，如记录日志
4. **Failback Cluster模式**，失败了后台自动记录请求，然后定时重发，适合写消息队列失败
5. **Forking Cluster模式**，并行调用多个provider，只要一个成功就立即返回。用于实时性要求较高的读操作，但是会浪费更多服务资源
6. **Broadcast Cluster模式**，逐个调用所有的provider,任何一个出错则报错。用于通知所有提供者更新缓存或日志等本地资源信息

## Dubbo的SPI思想

service provider interface

### spi概念

一个接口，有三个实现类，在系统运行时这个接口该选择哪个实现类？就需要根据指定的配置或者是默认的配置，找对应的实现类加载进来，用这个实现类的实例对象。**插件扩展的场景**

### java spi思想的体现

经典思想JDBC。java定义了一套jdbc的接口，并没有提供jdbc的实现类，所以可以使用mysql-jdbc-connector.jar引入或者oracle-jdbc-connector.jar

### dubbo的spi思想

Protocol 接口，在系统运行的时候，，dubbo 会判断一下应该选用这个 Protocol 接口的哪个实现类来实例化对象来使用，它会去找一个你配置的 Protocol，将你配置的 Protocol 实现类，加载到 jvm
中来，然后实例化对象，就用你的那个 Protocol 实现类就可以了

```java
Protocol protocol=ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
```

dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol http=com.alibaba.dubbo.rpc.protocol.http.HttpProtocol
hessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol

## 基于Dubbo的服务治理

服务治理：调用链路自动生成；服务访问压力以及时长统计

### 服务降级

接口+Mock后缀，如：

```xml

<dubbo:service interface="com.zhss.service.HelloService" ref="helloServiceImpl" timeout="10000"/><bean
id="helloServiceImpl" class="com.zhss.service.HelloServiceImpl"/>
```

降级逻辑 public class HelloServiceMock implements HelloService { public void sayHello() { // 降级逻辑 }}

### 失败重试/超时重试

```xml

<dubbo:reference id="xxxx" interface="xx" check="true" async="false" retries="3" timeout="2000"/>
```

timeOut:一般设置为200ms，retries:设置重试次数

## 分布式服务的幂等性如何设计

场景：假如有个服务部署在5台机器上，有个接口是付款接口，用户在前端操作，一个订单不小心发起了两次支付请求，然后分散在了这个服务部署的不同机器上

### 如何保证幂等性？

- 对于每个请求必须有一个唯一的标识，如：订单支付请求，订单id需要唯一
- 每次处理完请求后，必须有一个记录标识这个请求处理过了，如在mysql中记录个状态
- 每次接收请求需要进行判断，判断之前是否处理过。唯一键约束

## 分布式服务接口请求顺序如何保证

场景：服务A调用服务B，先插入再删除。结果俩请求过去，落在不同机器上，可能因为插入请求因为某些原因执行慢了，导致删除请求先执行了

### 如何保证顺序

- 尽量合并成一个操作，避免此问题产生
- 可以使用Dubbo的一致性hash负载均衡策略，将比如某一个订单id对应的请求都分发到某个机器上，然后可以将某个订单id对应的请求放到一个内存队列中，强制排队，来确保顺序性

  ![](/static/image-dubbo/dubbo-顺序性保证.png)

## 自己设计一个类似Dubbo的RPC框架

1. 注册中心服务注册，可以用zk
2. 消费者需要去注册中心拿对应服务信息，而且每个服务可能存在于多台机器上
3. 发起一次请求，基于动态代理，面向接口获取到一个动态代理，然后这个代理找到服务对应的机器地址
4. 使用简单的负载均衡策略确定向哪个机器发送请求
5. 使用netty,nio方式，使用hessian序列化协议
6. 服务器侧，针对自己的服务生成一个动态代理，监听某个网络端口

## CAP理论

CAP，Consistency一致性，Availability可用性，Partition tolerance分区容错性

- C:所有节点访问同一份最新的数据副本
- A:每次请求都能获取到正常响应，不保证获取的数据为最新数据
- P:分区相当于对通信的时限要求。系统不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择

常用的CAP框架

1. eureka(AP):保证可用，实现最终一致性。

## 分布式事务

## 基于Hystrix实现高可用