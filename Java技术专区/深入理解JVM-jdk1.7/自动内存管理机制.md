## Java内存区域与内存溢出
Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想
进去，墙里面的人却想出来

### 运行时数据区
![](https://llhyoudao.oss-cn-shenzhen.aliyuncs.com/%E6%9C%89%E9%81%93%E4%BA%91/1608802028%281%29.png)
- 所有线程共享的数据区：方法区、堆
- 线程隔离的数据区：虚拟机栈、本地方法栈、程序计数器

#### 程序计数器(Program Counter Register)
- 线程私有
- 一块内存较小的内存空间
- 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复etc基础功能都需要依赖这个计数器
- Java虚拟机的多线程：通过线程轮流切换并分配处理器执行时间的方式来实现，任何一个确定时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。
- 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

#### Java虚拟机栈
- 线程私有
- 每个方法在执行的同时都会创建一个栈帧（stack frame）用于存储局部变量表（栈内存）、操作数栈、动态链接，方法出口等信息。
- 每个方法从调用直至执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程
- 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象的句柄）和returnAddress类型（指向了一条字节码指令的地址）
- 64位的long和double占用2各局部变量空间。方法运行期间不会改变局部变量表的大小
- 这个区域有两种异常状况：线程请求栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，则会抛出OutOfMemoryError异常
- **总结**：栈帧：
    - 局部变量表
        - 各种基本数据类型
        - 对象引用
        - returnAddress类型
    - 操作数栈
    - 动态链接
    - 方法出口etc

#### 本地方法栈（Native Method Stack）
- 线程私有
- 与虚拟机栈的区别：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务
- Sun HotSpot虚拟机将本地方法栈与虚拟机栈合二为一
- 与虚拟机栈相同，也会抛出两种异常

#### Java堆（Java Heap）
- 大部分应用，堆是java虚拟机所管理的内存中最大的一块。
- 被所有线程共享的一块内存区域
- 虚拟机启动时创建
- 存放对象实例，几乎所有的对象实例都在这里分配内存。Java虚拟机规范中描述：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换[2]优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”。
- 垃圾收集器管理的主要区域，也被称为GC堆（Garbage Collected Heap）
- 从内存回收角度看，现在收集器基本都采用分代收集算法，所以Java堆还可以细分：新生代、老年代；再细致的有Eden空间、From Survivor空间、To Survivor空间。
- 从内存分配的角度看，线程共享的堆中能划分多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB），划分的目的是为了更好的回收内存，或者更快的分配内存。
- 堆可以处于物理上不连续的内存空间中。既可以实现城固定大小的，也可以是可扩展的（通过-Xmx和-Xms控制）。
- 堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常

#### 方法区（Method Area）
- 所有线程共享的一块区域
- 存储被虚拟机加载的类信息、常量、静态b变量、即时编译器编译后的代码等
- 1.7的虚拟机规范将方法区描述为堆的一个逻辑部分，但它却是非堆（non-heap）
- 在hotspot虚拟机上开发者来说，方法区也被称为永久代，但是两者并不等价，是因为hotspot的设计团队把GC的分代收集扩展到了方法区。其他虚拟机（如BEA JRockit、IBM J9等）不存在永久代的概念
- 方法区的GC回收也可以不实现
- 方法区（永久代的概念在1.8被取消，元空间来代替）

#### 运行时常量池（Runtime Constant Pool）
- 是方法区的一部分
- 存放编译器生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池
- 运行时常量池相对于class文件常量池的一个重要特征就是具备动态性，常量并非一定只有编译期才能产生，运行期间也可能将新的常量放入池中，比如string的intern()方法
- 常量池无法申请到内存的时候会抛出OutOfMemoryError异常

#### 直接内存（Direct Memory）
- 不是虚拟机运行时数据区的一部分
- 1.4时候新加入NIO（New input/output）类，引入基于通道channel与缓冲区buffer的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作
- 本机直接内存分配不会受到堆大小的限制，但是会受到本机内存大小以及处理器寻址空间的限制。在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，当忽略直接内存时，使得各个区域总和大于物理内存限制，导致动态扩展时出现OutOfMemoryError异常